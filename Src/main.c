/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <stdio.h>

#include "stm32f446xx.h"
#include "stm32f446xx_gpio.h"
#include "stm32f446xx_tim.h"

#define SIZEOF(arr) ((unsigned int)sizeof(arr) / sizeof(arr[0]))

#define FAST 100000
#define MEDIUM 300000
#define SLOW 1000000
#define WAIT(CNT)                              \
  do {                                         \
    for (int def_i = 0; def_i < CNT; def_i++); \
  } while (0)

/******* PINS *********/
#define LED_GREEN_PORT GPIOA
#define LED_GREEN_PIN 5
#define LED_GREEN_ALT_FN 1

#define USER_PBUTTON_PORT GPIOC
#define USER_PBUTTON_PIN 13

#define INPUT_CAPTURE_GPIO_PORT GPIOB
#define INPUT_CAPTURE_GPIO_PIN 6
#define INPUT_CAPTURE_GPIO_ALT_FN 2

#define PWM_GPIO_PORT GPIOB
#define PWM_GPIO_PIN 3
#define PWM_GPIO_ALT_FN 1

#define SPI_GPIO_PORT GPIOA
#define SPI_GPIO_NSS_PIN 4
#define SPI_GPIO_CLK_PIN 5
#define SPI_GPIO_MISO_PIN 6
#define SPI_GPIO_MOSI_PIN 7

/******* TIMERS ********/
#define TIM_TIMER_ADDR TIM5
#define TIM_CHANNEL 1

#define PWM_TIMER_ADDR TIM2
#define PWM_CHANNEL 2

#define INPUT_CAPTURE_ADDR TIM4
#define INPUT_CAPTURE_CHAN 1
#define OUTPUT_COMPARE_CHAN_LO 2
#define OUTPUT_COMPARE_CHAN_HI 3

/****** SPI *********/
#define SPI_PORT SPI1
#define SPI_BAUD_RATE 0b010

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
#warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

void setup_gpio();
void setup_timers();

void spi_setup_test();
void spi_tx(SPI_TypeDef *spi_port, uint8_t *tx_buffer, uint16_t len);

int main(void) {
  // setup_gpio();
  // setup_timers();

  spi_setup_test();

  // Create string for SPI testing
  char test_str[] = " WHO LET THE DOwaejfoiwefjiT";
  int len = SIZEOF(test_str);

  /* Loop forever */
  for (;;) {
    // Send SPI Tx
    spi_tx(SPI_PORT, (uint8_t *)test_str, len);
    WAIT(SLOW);
  }
}

void setup_gpio() {
  // Green LED for PA5 (on nucleo board)
  GPIO_peri_clock_control(LED_GREEN_PORT, GPIO_CLOCK_ENABLE);
  GPIOHandle_t led_green_handler = {.p_GPIO_addr = LED_GREEN_PORT,
                                    .cfg = {.mode = GPIO_MODE_OUT,
                                            .pin_number = LED_GREEN_PIN,
                                            .speed = GPIO_SPEED_LOW,
                                            .output_type = GPIO_OP_TYPE_PUSHPULL,
                                            .float_resistor = GPIO_PUPDR_NONE}};
  GPIO_init(&led_green_handler);

  // PWM Output externally wired to PB3, attached later to timer 2 channel 2
  GPIO_peri_clock_control(PWM_GPIO_PORT, GPIO_CLOCK_ENABLE);
  GPIOHandle_t pwm_handler = {.p_GPIO_addr = PWM_GPIO_PORT,
                              .cfg = {.mode = GPIO_MODE_ALTFN,
                                      .pin_number = PWM_GPIO_PIN,
                                      .speed = GPIO_SPEED_MEDIUM,
                                      .output_type = GPIO_OP_TYPE_PUSHPULL,
                                      .float_resistor = GPIO_PUPDR_NONE,
                                      .alt_func_num = PWM_GPIO_ALT_FN}};
  GPIO_init(&pwm_handler);

  // User button on PC13, attached to a falling edge interrupt IRQ
  GPIO_peri_clock_control(USER_PBUTTON_PORT, GPIO_CLOCK_ENABLE);
  GPIOHandle_t user_btn_handler = {.p_GPIO_addr = USER_PBUTTON_PORT,
                                   .cfg = {.mode = GPIO_MODE_IT_FT,
                                           .pin_number = USER_PBUTTON_PIN,
                                           .speed = GPIO_SPEED_LOW,
                                           .output_type = GPIO_OP_TYPE_PUSHPULL,
                                           .float_resistor = GPIO_PUPDR_PULLDOWN}};
  GPIO_init(&user_btn_handler);
  NVIC_EnableIRQ(EXTI15_10_IRQn);

  // Input capture on PB6, tied to a timer interrupt which captures the pulse width on timer 4 channel 1
  GPIO_peri_clock_control(INPUT_CAPTURE_GPIO_PORT, GPIO_CLOCK_ENABLE);
  GPIOHandle_t capture_handler = {.p_GPIO_addr = INPUT_CAPTURE_GPIO_PORT,
                                  .cfg = {.mode = GPIO_MODE_ALTFN,
                                          .pin_number = INPUT_CAPTURE_GPIO_PIN,
                                          .speed = GPIO_SPEED_HIGH,
                                          .output_type = GPIO_OP_TYPE_PUSHPULL,
                                          .float_resistor = GPIO_PUPDR_PULLDOWN,
                                          .alt_func_num = INPUT_CAPTURE_GPIO_ALT_FN}};
  GPIO_init(&capture_handler);
}

void setup_timers() {
  // For PWM on PB11
  timer_peri_clock_control(TIM2, TIMER_PERI_CLOCK_ENABLE);
  TimerHandle_t tim2_handle = {.p_base_addr = TIM2,
                               .cfg = {.arr = 1000,
                                       .channel_count = 4,
                                       .prescaler = 253,
                                       .channel_2 = {.gpio_en = TIMER_GPIO_ENABLE,
                                                     .interrupt_en = TIMER_INTERRUPT_DISABLE,
                                                     .channel_mode = TIMER_CHANNEL_MODE_PWM_HI,
                                                     .ccr = 0}}};
  timer_init(&tim2_handle);

  // For input capture on PB6 and some compare channels (2&3)
  timer_peri_clock_control(TIM4, TIMER_PERI_CLOCK_ENABLE);
  TimerHandle_t tim4_handle = {
      .p_base_addr = TIM4,
      .cfg = {
          .arr = 0xffff,
          .prescaler = 507,
          .channel_count = 3,
          .channel_1 = {.gpio_en = TIMER_GPIO_ENABLE,
                        .channel_mode = TIMER_CHANNEL_MODE_CAPTURE,
                        .interrupt_en = TIMER_INTERRUPT_ENABLE,
                        .capture_edge = TIMER_CAPTURE_BOTH_EDGE,
                        .capture_input_filter = TIMER_CAPTURE_FILTER_MEDIUM},
          .channel_2 = {.channel_mode = TIMER_CHANNEL_MODE_COMPARE, .interrupt_en = TIMER_INTERRUPT_ENABLE, .ccr = 0},
          .channel_3 = {
              .channel_mode = TIMER_CHANNEL_MODE_COMPARE, .interrupt_en = TIMER_INTERRUPT_ENABLE, .ccr = 0xffff / 4}}};
  timer_init(&tim4_handle);
  NVIC_EnableIRQ(TIM4_IRQn);
}

////// INTERRUPTS ///////
void TIM4_IRQHandler(void) {
  if (timer_irq_handling(INPUT_CAPTURE_ADDR, INPUT_CAPTURE_CHAN)) {
    uint8_t rising_edge = GPIO_get_input(INPUT_CAPTURE_GPIO_PORT, INPUT_CAPTURE_GPIO_PIN);
    static uint16_t capture_val = 0;
    static uint16_t capture_val_falling = 0;

    // Rising edge
    if (rising_edge) {
      capture_val_falling = timer_get_current_ticks(INPUT_CAPTURE_ADDR, INPUT_CAPTURE_CHAN);
    }
    // Falling edge
    else {
      capture_val = timer_get_current_ticks(INPUT_CAPTURE_ADDR, INPUT_CAPTURE_CHAN) - capture_val_falling;
      float pwm_alpha = (float)capture_val / timer_get_period_ticks(INPUT_CAPTURE_ADDR);
      timer_set_pwm_percent(PWM_TIMER_ADDR, PWM_CHANNEL, pwm_alpha);
    }
  }

  if (timer_irq_handling(INPUT_CAPTURE_ADDR, OUTPUT_COMPARE_CHAN_HI)) {
    GPIO_set_output(LED_GREEN_PORT, LED_GREEN_PIN, 1);
  }

  if (timer_irq_handling(INPUT_CAPTURE_ADDR, OUTPUT_COMPARE_CHAN_LO)) {
    GPIO_set_output(LED_GREEN_PORT, LED_GREEN_PIN, 0);
  }
}

void EXTI15_10_IRQHandler(void) {
  if (GPIO_irq_handling(USER_PBUTTON_PIN)) {
    timer_set_pwm_percent(PWM_TIMER_ADDR, PWM_CHANNEL, 0);
  }
}
////// END INTERRUPTS ///////

void spi_setup_test() {
  // The configuration procedure is almost the same for master and slave. For specific mode setups, follow the dedicated chapters. When a standard communication is to be initialized, perform these steps:

  // First enable RCC clock
  RCC->APB2ENR |= (1 << RCC_APB2ENR_SPI1EN_Pos);

  // 1.Write proper GPIO registers: Configure GPIO for MOSI, MISO and SCK pins.
  GPIO_peri_clock_control(SPI_GPIO_PORT, GPIO_CLOCK_ENABLE);
  GPIOConfig_t default_gpio_cfg = {.mode = GPIO_MODE_ALTFN,
                                   .speed = GPIO_SPEED_HIGH,
                                   .float_resistor = GPIO_PUPDR_NONE,
                                   .output_type = GPIO_OP_TYPE_PUSHPULL,
                                   .alt_func_num = 5};
  GPIOHandle_t spi_gpio_clk_handle = {.p_GPIO_addr = SPI_GPIO_PORT, .cfg = default_gpio_cfg};
  spi_gpio_clk_handle.cfg.pin_number = SPI_GPIO_CLK_PIN;
  GPIO_init(&spi_gpio_clk_handle);

  GPIOHandle_t spi_gpio_miso_handle = {.p_GPIO_addr = SPI_GPIO_PORT, .cfg = default_gpio_cfg};
  spi_gpio_miso_handle.cfg.pin_number = SPI_GPIO_MISO_PIN;
  GPIO_init(&spi_gpio_miso_handle);

  GPIOHandle_t spi_gpio_mosi_handle = {.p_GPIO_addr = SPI_GPIO_PORT, .cfg = default_gpio_cfg};
  spi_gpio_mosi_handle.cfg.pin_number = SPI_GPIO_MOSI_PIN;
  GPIO_init(&spi_gpio_mosi_handle);

  GPIOHandle_t spi_gpio_nss_handle = {.p_GPIO_addr = SPI_GPIO_PORT, .cfg = default_gpio_cfg};
  spi_gpio_nss_handle.cfg.pin_number = SPI_GPIO_NSS_PIN;
  GPIO_init(&spi_gpio_nss_handle);

  // 2.Write to the SPI_CR1 register:
  // a) Configure the serial clock baud rate using the BR[2:0] bits (Note: 3).
  // NOTE says: These bits should not be changed when communication is ongoing.
  SPI_PORT->CR1 |= (SPI_BAUD_RATE << SPI_CR1_BR_Pos);

  // b) Configure the CPOL and CPHA bits combination to define one of the fou  relationships between the data transfer and the serial clock. (Note: 2 - except the  case when CRC is enabled at TI mode).
  SPI_PORT->CR1 |= (0 << SPI_CR1_CPOL_Pos);
  SPI_PORT->CR1 |= (0 << SPI_CR1_CPHA_Pos);

  // c) Select simplex or half-duplex mode by configuring RXONLY or BIDIMODE and BIDIOE (RXONLY and BIDIMODE can't be set at the same time).
  SPI_PORT->CR1 |= (0 << SPI_CR1_BIDIMODE_Pos);
  // BIDIOE is bidirectional output enable (output-only on the pin, as opposed to input-only)

  // d) Configure the LSBFIRST bit to define the frame format (Note: 2).
  SPI_PORT->CR1 |= (0 << SPI_CR1_LSBFIRST_Pos);  // MSB first

  // e) Configure the CRCEN and CRCEN bits if CRC is needed (while SCK clock signal is at idle state
  SPI_PORT->CR1 |= (0 << SPI_CR1_CRCEN_Pos);

  // f) Configure SSM and SSI (Note: 2).
  SPI_PORT->CR1 |= (0 << SPI_CR1_SSM_Pos);
  SPI_PORT->CR1 |= (0 << SPI_CR1_SSI_Pos);

  // g) Configure the MSTR bit (in multimaster NSS configuration, avoid conflict state on NSS if master is configured to prevent MODF error).
  SPI_PORT->CR1 |= (1 << SPI_CR1_MSTR_Pos);

  // Ad hoc - turn software slave management on

  // h) Set the DFF bit to configure the data frame format (8 or 16 bits).
  SPI_PORT->CR1 |= (0 << SPI_CR1_DFF_Pos);  // 8-bit DFFs

  // 3:Write to SPI_CR2 register:
  //    a) Configure SSOE (Note: 1 & 2).
  SPI_PORT->CR2 |= (1 << SPI_CR2_SSOE_Pos);

  //    b) Set the FRF bit if the TI protocol is required. Motorola vs TI
  SPI_PORT->CR2 |= (0 << SPI_CR2_FRF_Pos);

  // 4.Write to SPI_CRCPR register: Configure the CRC polynomial if needed.

  // 5.Write proper DMA registers: Configure DMA streams dedicated for SPI Tx and Rx in DMA registers if the DMA streams are used.

  // Lastly, enable the SPI peripheral
  SPI_PORT->CR1 |= (1 << SPI_CR1_SPE_Pos);

  // NOTES: Seems like I can only enable master mode when SSI and SSM are 1
  // Otherwise, master gets forced to 0, and MODE FAULT turns to 1

  // REASON: According to the manual, if NSS is pulled low, MODF is set and master mode is cleared
  // Therefore it is recommended to have a pullup resistor if NSS pin is being used
  // Or have SSOE enabled, which drives the NSS signal low and only allows for one slave device
}

void spi_tx(SPI_TypeDef *spi_port, uint8_t *tx_buffer, uint16_t len) {
  // Get the amount of bytes per frame - Should be 1 bytes, or 2 bytes (dff=1)
  uint8_t dff_bytes = ((spi_port->CR1 >> SPI_CR1_DFF_Pos) & 0b1) + 1;

  while (len > 0) {
    // Get the next frame available
    uint16_t tx_word = 0;
    if (dff_bytes == 1)
      tx_word = *((uint8_t *)tx_buffer);
    else {
      tx_word = *((uint16_t *)tx_buffer);
      if (len == 1) tx_word &= 0xFF00;
    }

    // While the TX Buffer is not empty...
    while (!(spi_port->SR & (1 << SPI_SR_TXE_Pos)));
    spi_port->DR = tx_word;

    // Move buffer along to the next available frame
    tx_buffer += dff_bytes;
    len -= dff_bytes;
  }
}
