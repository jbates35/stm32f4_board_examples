/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <stdio.h>

#include "stm32f446xx.h"
#include "stm32f446xx_gpio.h"
#include "stm32f446xx_tim.h"

#define FAST 100000
#define MEDIUM 300000
#define SLOW 1000000
#define WAIT(CNT)                              \
  do {                                         \
    for (int def_i = 0; def_i < CNT; def_i++); \
  } while (0)

/******* PINS *********/
#define LED_GREEN_PORT GPIOA
#define LED_GREEN_PIN 5
#define LED_GREEN_ALT_FN 1

#define USER_PBUTTON_PORT GPIOC
#define USER_PBUTTON_PIN 13

/******* TIMERS ********/
#define TIM_TIMER_ADDR TIM5
#define TIM_CHANNEL 1

#define PWM_TIMER_ADDR TIM2
#define PWM_CHANNEL 4

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
#warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

void timer_setup_test(void);

/****** CUSTOM TIMER.h CODE STARTS HERE *******
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 **/

/****** END OF CUSTOM TIMER.h CODE STARTS HERE *******
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 **/

int main(void) {
  // RCC->CR |= RCC_CR_

  GPIO_peri_clock_control(LED_GREEN_PORT, GPIO_CLOCK_ENABLE);
  GPIO_peri_clock_control(USER_PBUTTON_PORT, GPIO_CLOCK_ENABLE);
  GPIO_peri_clock_control(GPIOB, GPIO_CLOCK_ENABLE);

  GPIO_Handle_t gpio_handle;
  GPIO_TypeDef **gpio_addr = &gpio_handle.p_GPIO_x;
  GPIO_PinConfig_t *gpio_cfg = &gpio_handle.GPIO_pin_config;

  *gpio_addr = LED_GREEN_PORT;
  gpio_cfg->GPIO_pin_number = LED_GREEN_PIN;
  gpio_cfg->GPIO_pin_mode = GPIO_MODE_ALTFN;
  gpio_cfg->GPIO_pin_speed = GPIO_SPEED_LOW;
  gpio_cfg->GPIO_pin_pupd_control = GPIO_PUPDR_NONE;
  gpio_cfg->GPIO_pin_out_type = GPIO_OP_TYPE_PUSHPULL;
  gpio_cfg->GPIO_pin_alt_func_mode = LED_GREEN_ALT_FN;
  GPIO_init(&gpio_handle);

  *gpio_addr = GPIOB;
  gpio_cfg->GPIO_pin_number = 2;
  gpio_cfg->GPIO_pin_mode = GPIO_MODE_ALTFN;
  gpio_cfg->GPIO_pin_speed = GPIO_SPEED_LOW;
  gpio_cfg->GPIO_pin_pupd_control = GPIO_PUPDR_NONE;
  gpio_cfg->GPIO_pin_out_type = GPIO_OP_TYPE_PUSHPULL;
  gpio_cfg->GPIO_pin_alt_func_mode = 1;
  GPIO_init(&gpio_handle);

  *gpio_addr = USER_PBUTTON_PORT;
  gpio_cfg->GPIO_pin_number = USER_PBUTTON_PIN;
  gpio_cfg->GPIO_pin_mode = GPIO_MODE_IT_FT;
  gpio_cfg->GPIO_pin_speed = GPIO_SPEED_LOW;
  gpio_cfg->GPIO_pin_pupd_control = GPIO_PUPDR_PULLDOWN;
  gpio_cfg->GPIO_pin_out_type = GPIO_OP_TYPE_PUSHPULL;
  gpio_cfg->GPIO_pin_alt_func_mode = 0;
  GPIO_init(&gpio_handle);
  GPIO_irq_interrupt_config(EXTI15_10_IRQn, GPIO_INT_ENABLE);

  TimerHandle_t timer_handle;
  TIM_TypeDef **timer_addr = &timer_handle.p_base_addr;
  TimerConfig_t *timer_cfg = &timer_handle.cfg;

  // Timer 5 configuration
  timer_peri_clock_control(TIM_TIMER_ADDR, TIMER_PERI_CLOCK_ENABLE);
  *timer_addr = TIM_TIMER_ADDR;

  // overall timer specific
  timer_cfg->prescaler = 999;  // 16E6 / (PSC + 1) = ~65536
  timer_cfg->arr = 16;
  timer_cfg->channel_count = 1;

  // channel specific
  timer_cfg->channel_1.interrupt_en = TIMER_INTERRUPT_ENABLE;
  timer_cfg->channel_1.ccr = 0;
  timer_cfg->channel_1.channel_mode = TIMER_CHANNEL_MODE_COMPARE;

  // Initialize timer, enable the associated ISR
  timer_init(&timer_handle);
  timer_irq_interrupt_config(TIM5_IRQn, TIMER_IRQ_ENABLE);

  // Timer 2 configuration
  timer_peri_clock_control(PWM_TIMER_ADDR, TIMER_PERI_CLOCK_ENABLE);
  *timer_addr = PWM_TIMER_ADDR;

  // overall timer specific
  timer_cfg->prescaler = 253;  // 16M / (PSC + 1) = ~65536
  timer_cfg->arr = 1000;
  timer_cfg->channel_count = 4;

  // channel specific
  timer_cfg->channel_4.interrupt_en = TIMER_INTERRUPT_DISABLE;
  timer_cfg->channel_4.ccr = 0;
  timer_cfg->channel_4.channel_mode = TIMER_CHANNEL_MODE_PWM_HI;
  timer_cfg->channel_4.gpio_en = TIMER_GPIO_ENABLE;

  timer_init(&timer_handle);

  /* Loop forever */
  for (;;) {
  }
}

void timer_setup_test(void) {
  // Timer 2 //

  //Enable counter
  // 1. Select the counter clock (internal, external, prescaler).
  RCC->APB1ENR |= (1 << RCC_APB1ENR_TIM2EN_Pos);

  // Set timer 2 as upcounter
  TIM2->CR1 |= (1 << TIM_CR1_DIR_Pos);

  // 2. Write the desired data in the TIMx_ARR and TIMx_CCRx registers.
  /* TIM2->ARR = 0xFFFF;         // Test these by toggling commenting on and off
  TIM2->CCR1 = 0xFFFF - 800;  // Test these by toggling commenting on and off */
  TIM2->CCR4 = 30;
  TIM2->ARR = 200;
  //
  // Set the prescaler value
  TIM2->PSC = 1000;

  // 4. Select the output mode. For example, one must write OCxM=011, OCxPE=0, CCxP=0 and CCxE=1 to toggle OCx output pin when CNT matches CCRx, CCRx preload is not used, OCx is enabled and active high.
  TIM2->CCER |= (1 << TIM_CCER_CC4E_Pos);
  TIM2->CCER &= ~(1 << TIM_CCER_CC4P_Pos);
  TIM2->CCMR2 = (0b110 << TIM_CCMR2_OC4M_Pos);

  // 5. Enable the counter by setting the CEN bit in the TIMx_CR1 register.CR1_CEN;
  TIM2->CR1 |= (1 << TIM_CR1_CEN_Pos);
}

void TIM5_IRQHandler(void) {
  static float pwm_alpha = 1;
  pwm_alpha += 0.001;
  if (pwm_alpha > 1.0) pwm_alpha = 0;

  if (timer_irq_handling(TIM_TIMER_ADDR, TIM_CHANNEL)) {
    timer_set_pwm_percent(PWM_TIMER_ADDR, PWM_CHANNEL, pwm_alpha);
  }
}

void EXTI15_10_IRQHandler(void) {
  if (GPIO_irq_handling(USER_PBUTTON_PIN)) {
    GPIO_toggle_output(LED_GREEN_PORT, LED_GREEN_PIN);
  }
}
