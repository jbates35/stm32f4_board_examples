// Will use as backup for main for now
/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

// NOTE:
// Where I am at right now:
// -DMA for some reason faults out with the FIFO buffer. This does not happen with it during ADC.
// -I can only send a message once. After sending one message, I cannot re-enable the DMA stream.
// -In circular mode, I can make an niterrupt which stops the DMA stream until we're ready again. THis seems to work okay.

#include "main.h"

#include <stdint.h>
#include <stdio.h>
#include <string.h>

#include "stm32f446xx.h"
#include "stm32f446xx_dma.h"
#include "stm32f446xx_gpio.h"
#include "stm32f446xx_spi.h"

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
#warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

#define SPI_PORT SPI1
#define SPI_BAUD_RATE 0b100

#define SPI_GPIO_PORT GPIOA
#define SPI_GPIO_CLK_PIN 5
#define SPI_GPIO_MISO_PIN 6
#define SPI_GPIO_MOSI_PIN 7

#define SPI_GPIO_NSS_PORT GPIOA
#define SPI_GPIO_NSS_PIN 4

#define DMA_SPI_TX_STREAM DMA2_Stream3
#define DMA_SPI_RX_STREAM DMA2_Stream2

//command codes
#define COMMAND_LED_CTRL 0x50
#define COMMAND_SENSOR_READ 0x51
#define COMMAND_LED_READ 0x52
#define COMMAND_PRINT 0x53
#define COMMAND_ID_READ 0x54

#define LED_ON 1
#define LED_OFF 0

#define NACK 0xA5
#define ACK 0xF5

#define LED_ON 1
#define LED_OFF 0
void spi_master_setup_test();
void spi_tx_in_for_loop();

void spi_driver_setup_master();

void spi_dma_driver_setup_master(uint8_t *in_arr, uint8_t *out_arr, uint16_t elements);
void spi_master_dma_exti_handler();

void talk_to_arduino_dma(uint8_t *tx_arr, uint8_t *rx_arr);
void talk_to_arduino();
int talk_to_mcp3008(int channel);

void talk_to_mcp3008_dma(uint8_t channel, uint8_t *tx_arr, uint8_t *rx_arr);

void enable_spi_interrupt(SPI_TypeDef *spi_port);

char dma_tx_str[17];
uint8_t ard_dma_tx[4];
uint8_t ard_dma_rx[4];

int main(void) {
  // AFTER THIS, TRY OUT SLAVE MODE
  // NEED TO GET INTERRUPT GOING

  uint8_t mcp3008_dma_tx[3] = {1, (1 << 7) | (1 << 4), 0};
  uint8_t mcp3008_dma_rx[3];

  spi_dma_driver_setup_master(mcp3008_dma_tx, mcp3008_dma_rx, 3);

  for (;;) {
    dma_start_transfer(DMA_SPI_RX_STREAM, 3);
    GPIO_set_output(SPI_GPIO_NSS_PORT, SPI_GPIO_NSS_PIN, 0);
    dma_start_transfer(DMA_SPI_TX_STREAM, 3);
    WAIT(FAST);
  }
}

void EXTI15_10_IRQHandler(void) {
  if (GPIO_irq_handling(USER_PBUTTON_PIN)) {
    talk_to_arduino();
  }
}

void DMA2_Stream2_IRQHandler(void) {
  if (dma_irq_handling(DMA_SPI_RX_STREAM, DMA_INTERRUPT_TYPE_FULL_TRANSFER_COMPLETE)) {
    uint8_t *rx_arr = (uint8_t *) (DMA_SPI_RX_STREAM->M0AR);

    GPIO_set_output(SPI_GPIO_NSS_PORT, SPI_GPIO_NSS_PIN, 1);
    uint16_t adc_val = ((rx_arr[1] & 3) << 8) | rx_arr[2];
    int breakpoint_set_here = 0;
  }
}
void talk_to_arduino() {
  static uint8_t method_num = 0;

  uint8_t cmd_tx_bytes[2] = {0xFF, 2};
  uint8_t cmd_rx_bytes[2] = {0};

  uint8_t sig_tx_bytes[2] = {0};
  uint8_t sig_rx_bytes[2] = {0};

  switch (method_num) {
    case 0:
      cmd_tx_bytes[0] = COMMAND_LED_CTRL;
      sig_tx_bytes[0] = 9;
      sig_tx_bytes[1] = 1;
      break;
    case 1:
      cmd_tx_bytes[0] = COMMAND_SENSOR_READ;
      break;
    case 2:
      cmd_tx_bytes[0] = COMMAND_LED_CTRL;
      sig_tx_bytes[0] = 9;
      sig_tx_bytes[1] = 0;
      break;
  }

  // Send dat data
  GPIO_set_output(SPI_GPIO_NSS_PORT, SPI_GPIO_NSS_PIN, 0);

  spi_full_duplex_transfer(SPI1, cmd_tx_bytes, cmd_rx_bytes, 2);

  if (cmd_rx_bytes[1] == ACK) {
    spi_full_duplex_transfer(SPI1, &sig_tx_bytes[0], &sig_rx_bytes[0], 1);
    WAIT(FAST);  // Needed for the amount of time Arduino needs to have to sample the  ADC val
    spi_full_duplex_transfer(SPI1, &sig_tx_bytes[1], &sig_rx_bytes[1], 1);
  }

  GPIO_set_output(SPI_GPIO_NSS_PORT, SPI_GPIO_NSS_PIN, 1);

  uint8_t sensor_read = sig_rx_bytes[1];
  if (method_num == 1) printf("Result of sensor read: %d\n", sensor_read);

  method_num = (method_num + 1) % 3;
}

int full_duplex_arduino_main_func() {
  setup_gpio();
  spi_master_setup_test();

  for (;;) {
    talk_to_arduino();
    WAIT(SLOW);
  }
}

void spi_driver_setup_master() {
  // 1.Write proper GPIO registers: Configure GPIO for MOSI, MISO and SCK pins.
  GPIO_peri_clock_control(SPI_GPIO_PORT, GPIO_CLOCK_ENABLE);
  GPIO_peri_clock_control(SPI_GPIO_NSS_PORT, GPIO_CLOCK_ENABLE);
  GPIOConfig_t default_gpio_cfg = {.mode = GPIO_MODE_ALTFN,
                                   .speed = GPIO_SPEED_HIGH,
                                   .float_resistor = GPIO_PUPDR_NONE,
                                   .output_type = GPIO_OP_TYPE_PUSHPULL,
                                   .alt_func_num = 5};
  GPIOHandle_t spi_gpio_clk_handle = {.p_GPIO_addr = SPI_GPIO_PORT, .cfg = default_gpio_cfg};
  spi_gpio_clk_handle.cfg.pin_number = SPI_GPIO_CLK_PIN;
  GPIO_init(&spi_gpio_clk_handle);

  GPIOHandle_t spi_gpio_miso_handle = {.p_GPIO_addr = SPI_GPIO_PORT, .cfg = default_gpio_cfg};
  spi_gpio_miso_handle.cfg.pin_number = SPI_GPIO_MISO_PIN;
  GPIO_init(&spi_gpio_miso_handle);

  GPIOHandle_t spi_gpio_mosi_handle = {.p_GPIO_addr = SPI_GPIO_PORT, .cfg = default_gpio_cfg};
  spi_gpio_mosi_handle.cfg.pin_number = SPI_GPIO_MOSI_PIN;
  GPIO_init(&spi_gpio_mosi_handle);

  GPIOHandle_t spi_gpio_nss_handle = {.p_GPIO_addr = SPI_GPIO_NSS_PORT, .cfg = default_gpio_cfg};
  spi_gpio_nss_handle.cfg.pin_number = SPI_GPIO_NSS_PIN;
  spi_gpio_nss_handle.cfg.alt_func_num = 0;
  spi_gpio_nss_handle.cfg.mode = GPIO_MODE_OUT;
  GPIO_init(&spi_gpio_nss_handle);
  GPIO_set_output(SPI_GPIO_NSS_PORT, SPI_GPIO_NSS_PIN, 1);

  spi_peri_clock_control(SPI_PORT, SPI_PERI_CLOCK_ENABLE);
  SPIHandle_t spi_handle = {.addr = SPI_PORT,
                            .cfg = {.baud_divisor = SPI_BAUD_DIVISOR_32,
                                    .bus_config = SPI_BUS_CONFIG_FULL_DUPLEX,
                                    .device_mode = SPI_DEVICE_MODE_MASTER,
                                    .dff = SPI_DFF_8_BIT,
                                    .ssm = SPI_SSM_ENABLE,
                                    .dma_setup = {.rx = SPI_DMA_DISABLE, .tx = SPI_DMA_DISABLE},
                                    .interrupt_setup.en = SPI_INTERRUPT_DISABLE}};
  spi_init(&spi_handle);
}

void spi_dma_driver_setup_master(uint8_t *tx_arr, uint8_t *rx_arr, uint16_t elements) {
  dma_peri_clock_control(DMA2, 1);
  DMAHandle_t spi_dma_tx_handle = {
      .cfg = {.in = {.addr = (uintptr_t)tx_arr, .type = DMA_IO_TYPE_MEMORY, .inc = DMA_IO_ARR_INCREMENT},
              .out = {.addr = (uintptr_t)&SPI_PORT->DR, .type = DMA_IO_TYPE_PERIPHERAL, .inc = DMA_IO_ARR_STATIC},
              .mem_data_size = DMA_DATA_SIZE_8_BIT,
              .peri_data_size = DMA_DATA_SIZE_8_BIT,
              .dma_elements = elements,
              .channel = 3,
              .priority = DMA_PRIORITY_MAX,
              .circ_buffer = DMA_BUFFER_FINITE,
              .flow_control = DMA_PERIPH_NO_FLOW_CONTROL,
              .interrupt_en =
                  {
                      .direct_mode_error = DMA_INTERRUPT_DISABLE,
                      .transfer_error = DMA_INTERRUPT_DISABLE,
                      .full_transfer = DMA_INTERRUPT_DISABLE,
                      .half_transfer = DMA_INTERRUPT_DISABLE,
                  },
              .start_enabled = DMA_START_DISABLED},
      .p_stream_addr = DMA_SPI_TX_STREAM};
  dma_stream_init(&spi_dma_tx_handle);

  DMAHandle_t spi_dma_rx_handle = {
      .cfg = {.in = {.addr = (uintptr_t)&SPI_PORT->DR, .type = DMA_IO_TYPE_PERIPHERAL, .inc = DMA_IO_ARR_STATIC},
              .out = {.addr = (uintptr_t)rx_arr, .type = DMA_IO_TYPE_MEMORY, .inc = DMA_IO_ARR_INCREMENT},
              .mem_data_size = DMA_DATA_SIZE_8_BIT,
              .peri_data_size = DMA_DATA_SIZE_8_BIT,
              .dma_elements = elements,
              .channel = 3,
              .priority = DMA_PRIORITY_HIGH,
              .circ_buffer = DMA_BUFFER_FINITE,
              .flow_control = DMA_PERIPH_NO_FLOW_CONTROL,
              .interrupt_en =
                  {
                      .direct_mode_error = DMA_INTERRUPT_DISABLE,
                      .transfer_error = DMA_INTERRUPT_DISABLE,
                      .full_transfer = DMA_INTERRUPT_ENABLE,
                      .half_transfer = DMA_INTERRUPT_DISABLE,
                  },
              .start_enabled = DMA_START_DISABLED},
      .p_stream_addr = DMA_SPI_RX_STREAM};
  dma_stream_init(&spi_dma_rx_handle);
  dma_peri_clock_control(DMA2, 1);
  NVIC_EnableIRQ(DMA2_Stream2_IRQn);

  GPIO_peri_clock_control(SPI_GPIO_PORT, GPIO_CLOCK_ENABLE);
  GPIO_peri_clock_control(SPI_GPIO_NSS_PORT, GPIO_CLOCK_ENABLE);
  GPIOConfig_t default_gpio_cfg = {.mode = GPIO_MODE_ALTFN,
                                   .speed = GPIO_SPEED_HIGH,
                                   .float_resistor = GPIO_PUPDR_NONE,
                                   .output_type = GPIO_OP_TYPE_PUSHPULL,
                                   .alt_func_num = 5};
  GPIOHandle_t spi_gpio_clk_handle = {.p_GPIO_addr = SPI_GPIO_PORT, .cfg = default_gpio_cfg};
  spi_gpio_clk_handle.cfg.pin_number = SPI_GPIO_CLK_PIN;
  GPIO_init(&spi_gpio_clk_handle);

  GPIOHandle_t spi_gpio_miso_handle = {.p_GPIO_addr = SPI_GPIO_PORT, .cfg = default_gpio_cfg};
  spi_gpio_miso_handle.cfg.pin_number = SPI_GPIO_MISO_PIN;
  GPIO_init(&spi_gpio_miso_handle);

  GPIOHandle_t spi_gpio_mosi_handle = {.p_GPIO_addr = SPI_GPIO_PORT, .cfg = default_gpio_cfg};
  spi_gpio_mosi_handle.cfg.pin_number = SPI_GPIO_MOSI_PIN;
  GPIO_init(&spi_gpio_mosi_handle);

  GPIOHandle_t spi_gpio_nss_handle = {.p_GPIO_addr = SPI_GPIO_NSS_PORT, .cfg = default_gpio_cfg};
  spi_gpio_nss_handle.cfg.pin_number = SPI_GPIO_NSS_PIN;
  spi_gpio_nss_handle.cfg.alt_func_num = 0;
  spi_gpio_nss_handle.cfg.mode = GPIO_MODE_OUT;
  GPIO_init(&spi_gpio_nss_handle);
  GPIO_set_output(SPI_GPIO_NSS_PORT, SPI_GPIO_NSS_PIN, 1);

  spi_peri_clock_control(SPI_PORT, SPI_PERI_CLOCK_ENABLE);
  SPIHandle_t spi_handle = {.addr = SPI_PORT,
                            .cfg = {.baud_divisor = SPI_BAUD_DIVISOR_32,
                                    .bus_config = SPI_BUS_CONFIG_FULL_DUPLEX,
                                    .device_mode = SPI_DEVICE_MODE_MASTER,
                                    .dff = SPI_DFF_8_BIT,
                                    .ssm = SPI_SSM_ENABLE,
                                    .dma_setup = {.rx = SPI_DMA_ENABLE, .tx = SPI_DMA_ENABLE},
                                    .interrupt_setup.en = SPI_INTERRUPT_DISABLE}};
  spi_init(&spi_handle);
}

void talk_to_arduino_dma(uint8_t *tx_arr, uint8_t *rx_arr) {
  static uint8_t method_num = 0;
  GPIO_set_output(SPI_GPIO_NSS_PORT, SPI_GPIO_NSS_PIN, 0);

  tx_arr[1] = 2;
  if (method_num == 0 || method_num == 2)
    tx_arr[0] = COMMAND_LED_CTRL;
  else if (method_num == 1)
    tx_arr[0] = COMMAND_SENSOR_READ;

  WAIT(FAST);

  dma_start_transfer(DMA_SPI_TX_STREAM, 1);
  int breakpoint1 = 0;

  tx_arr[0] = 2;
  WAIT(FAST);
  dma_start_transfer(DMA_SPI_TX_STREAM, 1);
  WAIT(FAST);

  if (rx_arr[0] == ACK) {
    if (method_num == 0) {
      tx_arr[0] = 9;
      dma_start_transfer(DMA_SPI_TX_STREAM, 1);
      WAIT(FAST);
      tx_arr[0] = 1;
      dma_start_transfer(DMA_SPI_TX_STREAM, 1);
    } else if (method_num == 1) {
      tx_arr[0] = 0;
      dma_start_transfer(DMA_SPI_TX_STREAM, 1);
      WAIT(FAST);
      dma_start_transfer(DMA_SPI_TX_STREAM, 1);
      printf("Result of sensor read: %d\n", rx_arr[3]);
    } else if (method_num == 2) {
      tx_arr[0] = 9;
      tx_arr[1] = 0;
      dma_start_transfer(DMA_SPI_TX_STREAM, 2);
    }
  }

  WAIT(FAST);
  GPIO_set_output(SPI_GPIO_NSS_PORT, SPI_GPIO_NSS_PIN, 1);
  method_num = (method_num + 1) % 3;
}

void talk_to_mcp3008_dma(uint8_t channel, uint8_t *tx_arr, uint8_t *rx_arr) {
  // Look to mcp3008 for pattern needed to be sent
  tx_arr[0] = 1;
  tx_arr[1] = (1 << 7) | ((channel & 0b111) << 4);
  tx_arr[2] = 0;

  dma_start_transfer(DMA_SPI_RX_STREAM, 3);

  GPIO_set_output(SPI_GPIO_NSS_PORT, SPI_GPIO_NSS_PIN, 0);

  dma_start_transfer(DMA_SPI_TX_STREAM, 3);
}

void spi_master_dma_exti_handler() {
  if (GPIO_irq_handling(USER_PBUTTON_PIN)) {
    memset(&dma_tx_str, 0, SIZEOF(dma_tx_str));
    char test_str[] = "asdfjkl lkjfdsa";
    int len = SIZEOF(test_str);
    dma_tx_str[0] = (char)len;
    strcat(dma_tx_str, test_str);

    dma_start_transfer(DMA_SPI_TX_STREAM, SIZEOF(dma_tx_str));
  }
}
