
/**
 ****************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>

#include "stm32f446xx.h"
#include "stm32f446xx_gpio.h"
#include "stm32f446xx_spi.h"

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
#warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

#define SPI_PORT SPI1

#define SPI_GPIO_PORT GPIOA
#define SPI_GPIO_CLK_PIN 5
#define SPI_GPIO_MISO_PIN 6
#define SPI_GPIO_MOSI_PIN 7

#define SPI_GPIO_NSS_PORT GPIOA
#define SPI_GPIO_NSS_PIN 4

#define FAST 100000
#define MEDIUM 300000
#define SLOW 1000000
#define WAIT(CNT)                                          \
  do {                                                     \
    for (int sleep_cnt = 0; sleep_cnt < CNT; sleep_cnt++); \
  } while (0)

#define SIZEOF(arr) ((unsigned int)sizeof(arr) / sizeof(arr[0]))

void spi_driver_setup_interrupts();
void spi_int_func(void);

uint8_t mcp3008_tx[2] = {1, (1 << 7) | (1 << 4)};  // , 0};
uint8_t mcp3008_rx[3];

int main(void) {
  spi_driver_setup_interrupts();

  spi_setup_interrupt(SPI_PORT, SPI_INTERRUPT_TYPE_TX, (char *)mcp3008_tx, SIZEOF(mcp3008_tx));
  spi_setup_interrupt(SPI_PORT, SPI_INTERRUPT_TYPE_RX, (char *)mcp3008_rx, SIZEOF(mcp3008_rx));
  spi_set_circular_interrupt(SPI_PORT, SPI_INTERRUPT_CIRCULAR);
  spi_set_interrupt_callback(SPI_PORT, &spi_int_func);

  // Since this is set up in circular mode, it will automatically restart when spi is done transferring the word
  spi_start_int_word_transfer(SPI_PORT);

  for (;;) {
  }
}

void SPI1_IRQHandler(void) { spi_irq_word_handling(SPI1); }

void spi_int_func(void) {
  GPIO_set_output(SPI_GPIO_NSS_PORT, SPI_GPIO_NSS_PIN, 1);
  int adc_val = ((mcp3008_rx[1] & 0x3) << 8) + mcp3008_rx[2];

  // Add a little bit of time for the GPIO pin to go high and then low to reset mcp3008
  for (int i = 0; i < 20; i++);

  GPIO_set_output(SPI_GPIO_NSS_PORT, SPI_GPIO_NSS_PIN, 0);
}

void spi_driver_setup_interrupts() {
  // 1.Write proper GPIO registers: Configure GPIO for MOSI, MISO and SCK pins.
  GPIO_peri_clock_control(SPI_GPIO_PORT, GPIO_CLOCK_ENABLE);
  GPIO_peri_clock_control(SPI_GPIO_NSS_PORT, GPIO_CLOCK_ENABLE);
  GPIOConfig_t default_gpio_cfg = {.mode = GPIO_MODE_ALTFN,
                                   .speed = GPIO_SPEED_HIGH,
                                   .float_resistor = GPIO_PUPDR_NONE,
                                   .output_type = GPIO_OP_TYPE_PUSHPULL,
                                   .alt_func_num = 5};
  GPIOHandle_t spi_gpio_clk_handle = {.p_GPIO_addr = SPI_GPIO_PORT, .cfg = default_gpio_cfg};
  spi_gpio_clk_handle.cfg.pin_number = SPI_GPIO_CLK_PIN;
  GPIO_init(&spi_gpio_clk_handle);

  GPIOHandle_t spi_gpio_miso_handle = {.p_GPIO_addr = SPI_GPIO_PORT, .cfg = default_gpio_cfg};
  spi_gpio_miso_handle.cfg.pin_number = SPI_GPIO_MISO_PIN;
  GPIO_init(&spi_gpio_miso_handle);

  GPIOHandle_t spi_gpio_mosi_handle = {.p_GPIO_addr = SPI_GPIO_PORT, .cfg = default_gpio_cfg};
  spi_gpio_mosi_handle.cfg.pin_number = SPI_GPIO_MOSI_PIN;
  GPIO_init(&spi_gpio_mosi_handle);

  GPIOHandle_t spi_gpio_nss_handle = {.p_GPIO_addr = SPI_GPIO_NSS_PORT, .cfg = default_gpio_cfg};
  spi_gpio_nss_handle.cfg.pin_number = SPI_GPIO_NSS_PIN;
  spi_gpio_nss_handle.cfg.alt_func_num = 0;
  spi_gpio_nss_handle.cfg.mode = GPIO_MODE_OUT;
  GPIO_init(&spi_gpio_nss_handle);
  GPIO_set_output(SPI_GPIO_NSS_PORT, SPI_GPIO_NSS_PIN, 1);

  spi_peri_clock_control(SPI_PORT, SPI_ENABLE);
  SPIHandle_t spi_handle = {.addr = SPI_PORT,
                            .cfg = {.baud_divisor = SPI_BAUD_DIVISOR_256,
                                    .bus_config = SPI_BUS_CONFIG_FULL_DUPLEX,
                                    .device_mode = SPI_DEVICE_MODE_MASTER,
                                    .dff = SPI_DFF_8_BIT,
                                    .ssm = SPI_SSM_ENABLE,
                                    .dma_setup = {.rx = SPI_DISABLE, .tx = SPI_DISABLE},
                                    .enable_on_init = SPI_ENABLE}};
  spi_init(&spi_handle);

  NVIC_EnableIRQ(SPI1_IRQn);
}
