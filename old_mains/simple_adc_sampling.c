

/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>

#include "stm32f446xx.h"
#include "stm32f446xx_adc.h"
#include "stm32f446xx_gpio.h"

#define SIZEOF(arr) ((unsigned int)sizeof(arr) / sizeof(arr[0]))

#define FAST 100000
#define MEDIUM 300000
#define SLOW 1000000
#define WAIT(CNT)                                          \
  do {                                                     \
    for (int sleep_cnt = 0; sleep_cnt < CNT; sleep_cnt++); \
  } while (0)

#define ADC1_CHAN0_GPIO_PORT GPIOA
#define ADC1_CHAN0_GPIO_PIN 0

#define ADC1_CHAN1_GPIO_PORT GPIOA
#define ADC1_CHAN1_GPIO_PIN 1

void adc_gpio_setup();
void adc_driver_single_setup();

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
#warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

int main(void) {
  adc_gpio_setup();
  adc_driver_single_setup();

  for (;;) {
    uint16_t val1 = adc_single_sample(ADC1, 0, ADC_CHANNEL_SPEED_MEDIUM, ADC_BLOCKING);
    WAIT(FAST);
    uint16_t val2 = adc_single_sample(ADC1, 1, ADC_CHANNEL_SPEED_MEDIUM, ADC_BLOCKING);
    WAIT(FAST);
    uint16_t val3 = adc_single_sample(ADC1, 18, ADC_CHANNEL_SPEED_MEDIUM, ADC_BLOCKING);
    WAIT(MEDIUM);
  }
}

void adc_gpio_setup() {
  // PA 0 and 1 will be the ADC channels. That relates to ADC channels 0 and 1
  GPIOConfig_t cfg = {.mode = GPIO_MODE_ANALOG, .speed = GPIO_SPEED_MEDIUM, .float_resistor = GPIO_PUPDR_NONE};

  // ADC 0
  GPIO_peri_clock_control(ADC1_CHAN0_GPIO_PORT, GPIO_CLOCK_ENABLE);
  GPIOHandle_t adc0_handler = {.p_GPIO_addr = ADC1_CHAN0_GPIO_PORT, .cfg = cfg};
  adc0_handler.cfg.pin_number = ADC1_CHAN0_GPIO_PIN;
  GPIO_init(&adc0_handler);

  // ADC 1
  GPIO_peri_clock_control(ADC1_CHAN1_GPIO_PORT, GPIO_CLOCK_ENABLE);
  GPIOHandle_t adc1_handler = {.p_GPIO_addr = ADC1_CHAN1_GPIO_PORT, .cfg = cfg};
  adc1_handler.cfg.pin_number = ADC1_CHAN1_GPIO_PIN;
  GPIO_init(&adc1_handler);
}

void adc_driver_single_setup() {
  ADCHandle_t adc_init_struct = {.addr = ADC1,
                                 .cfg = {.dual_cfg.en = ADC_DUAL_MODE_DISABLE,
                                         .inj_autostart = ADC_INJ_AUTOSTART_OFF,
                                         .interrupt_en = ADC_INTERRUPT_DISABLE,
                                         .main_inj_chan_cfg.en = ADC_SCAN_DISABLE,
                                         .main_seq_chan_cfg.en = ADC_SCAN_DISABLE,
                                         .temp_or_bat_en = ADC_TEMPORBAT_TEMPERATURE,
                                         .resolution = ADC_RESOLUTION_12_BIT,
                                         .trigger_cfg.mode = ADC_TRIGGER_MODE_MANUAL}};
  adc_peri_clock_control(ADC1, 1);
  adc_init(&adc_init_struct);
}
