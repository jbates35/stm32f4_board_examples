/**
 ****************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

/*
  EXAMPLE OF SPI INTERRUPT SEND/RECV WITH AN ARDUINO
  Does NOT use the full word interrupt. For that, check out spi_talk_to_mcp3008_interrupt
  Requires an Arduino with 002SPISlaveCmdHandling.ino
*/

#include <stdint.h>
#include <stdio.h>
#include <string.h>

#include "stm32f446xx.h"
#include "stm32f446xx_gpio.h"
#include "stm32f446xx_i2c.h"

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
#warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

int _write(int le, char *ptr, int len) {
  int DataIdx;
  for (DataIdx = 0; DataIdx < len; DataIdx++) {
    ITM_SendChar(*ptr++);
  }
  return len;
}

#define I2C_GPIO_PORT GPIOB
#define I2C_GPIO_SCL_PIN 8
#define I2C_GPIO_SDA_PIN 9

#define I2C_PORT I2C1

#define SIZEOF(arr) ((unsigned int)sizeof(arr) / sizeof(arr[0]))

#define FAST 100000
#define MEDIUM 300000
#define SLOW 1000000
#define WAIT(CNT)                                          \
  do {                                                     \
    for (int sleep_cnt = 0; sleep_cnt < CNT; sleep_cnt++); \
  } while (0)

typedef struct {
  int16_t accel_x;    // Accelerometer x
  int16_t accel_y;    // Accelerometer y
  int16_t accel_z;    // Accelerometer z
  int16_t gyro_rx;    // Gyroscope rx
  int16_t gyro_ry;    // Gyroscope ry
  int16_t gyro_rz;    // Gyroscope rz
  float temperature;  // Temperature
} MPU6050Data;

MPU6050Data convert_gyro_data(uint8_t *buf);
void i2c_interrupt_driver_setup();

typedef struct {
  uint8_t arr[1000];
  uint16_t len;
  uint16_t eles_left;
  uint8_t en;
} I2CBuff_t;

I2CBuff_t i2c_tx_buff = {0};
I2CBuff_t i2c_rx_buff = {0};
uint8_t tx_byte = 0x3B;
uint8_t rx_buff[14] = {0x0};

static inline void tx_callback() {}
static inline void rx_cb() {
  MPU6050Data mpu_data = convert_gyro_data(i2c_rx_buff.arr);
  printf("Accel x: %d\n", mpu_data.accel_x);
  printf("Accel y: %d\n", mpu_data.accel_y);
  printf("Accel z: %d\n", mpu_data.accel_z);
  printf("Gyro rx: %d\n", mpu_data.gyro_rx);
  printf("Gyro ry: %d\n", mpu_data.gyro_ry);
  printf("Gyro rz: %d\n", mpu_data.gyro_rz);
  printf("MPU temperature: %f\n\n", mpu_data.temperature);
}

static inline void start_interrupt(I2C_TypeDef *i2c_reg) { i2c_reg->CR1 |= I2C_CR1_START; }
static inline void send_addr(I2C_TypeDef *i2c_reg, uint8_t addr, uint8_t lsb) { i2c_reg->DR = ((addr << 1) | lsb); }
static inline void init_xmission(I2C_TypeDef *i2c_reg, uint8_t ack) {
  if (ack) i2c_reg->CR1 |= I2C_CR1_ACK;
  i2c_reg->CR2 |= I2C_CR2_ITBUFEN;
  (void)i2c_reg->SR1;
  (void)i2c_reg->SR2;
}

static inline void send_data(I2C_TypeDef *i2c_reg, I2CBuff_t *tx_buff) {
  if (tx_buff->eles_left == 0 || tx_buff->eles_left > tx_buff->len) return;

  int i = tx_buff->len - tx_buff->eles_left;
  i2c_reg->DR = tx_buff->arr[i];
  tx_buff->eles_left--;
}

static inline void end_tx(I2C_TypeDef *i2c_reg, I2CBuff_t *tx_buff, I2CBuff_t *rx_buff) {
  if (!(i2c_reg->SR1 & I2C_SR1_BTF)) return;

  i2c_reg->CR2 &= ~I2C_CR2_ITBUFEN;
  if (!rx_buff->en)
    i2c_reg->CR1 |= I2C_CR1_STOP;
  else
    i2c_reg->CR1 |= I2C_CR1_START;

  tx_buff->en = 0;
}

static inline void single_byte_rx_handler(I2C_TypeDef *i2c_reg, I2CBuff_t *rx_buff) {
  if (rx_buff->len != 1) return;

  // Set ack low and set stop bit high
  i2c_reg->CR1 &= ~(1 << I2C_CR1_ACK_Pos);
  i2c_reg->CR1 |= (1 << I2C_CR1_STOP_Pos);

  // Clear flags
  (void)i2c_reg->SR1;
  (void)i2c_reg->SR2;
}

static inline void receive_data(I2C_TypeDef *i2c_reg, I2CBuff_t *rx_buff) {
  if (rx_buff->eles_left == 0 || rx_buff->eles_left > rx_buff->len) return;

  if (rx_buff->eles_left == 2) {
    i2c_reg->CR1 &= ~(1 << I2C_CR1_ACK_Pos);
    i2c_reg->CR1 |= (1 << I2C_CR1_STOP_Pos);
  }

  int i = rx_buff->len - rx_buff->eles_left;
  rx_buff->arr[i] = (uint8_t)i2c_reg->DR;
  rx_buff->eles_left--;

  if (!rx_buff->eles_left) {
    i2c_reg->CR2 &= ~I2C_CR2_ITBUFEN;
    rx_buff->en = 0;
    rx_cb();
  }
}

int main(void) {
  i2c_interrupt_driver_setup();

  uint8_t gyro_addr = 0x68;
  uint8_t wake_mpu[] = {0x6B, 0x00};

  WAIT(FAST);

  printf("Starting...\n\n");

  memcpy(i2c_tx_buff.arr, wake_mpu, SIZEOF(wake_mpu));
  i2c_tx_buff.len = SIZEOF(wake_mpu);
  i2c_tx_buff.eles_left = SIZEOF(wake_mpu);
  i2c_tx_buff.en = 1;

  start_interrupt(I2C_PORT);

  WAIT(FAST);

  i2c_tx_buff.arr[0] = tx_byte;
  i2c_tx_buff.len = 1;
  i2c_tx_buff.eles_left = 1;
  i2c_tx_buff.en = 1;

  memcpy(i2c_rx_buff.arr, rx_buff, SIZEOF(rx_buff));
  i2c_rx_buff.len = SIZEOF(rx_buff);
  i2c_rx_buff.eles_left = SIZEOF(rx_buff);
  i2c_rx_buff.en = 1;

  start_interrupt(I2C_PORT);

  for (;;) {
    WAIT(SLOW);
    i2c_tx_buff.arr[0] = tx_byte;
    i2c_tx_buff.len = 1;
    i2c_tx_buff.eles_left = 1;
    i2c_tx_buff.en = 1;

    memcpy(i2c_rx_buff.arr, rx_buff, SIZEOF(rx_buff));
    i2c_rx_buff.len = SIZEOF(rx_buff);
    i2c_rx_buff.eles_left = SIZEOF(rx_buff);
    i2c_rx_buff.en = 1;

    start_interrupt(I2C_PORT);
    WAIT(FAST);
    int breakpointhere = 0;
  }
}

void I2C1_EV_IRQHandler(void) {
  I2CIRQType_t int_type = i2c_irq_event_handling(I2C1);
  // TX:
  if (i2c_tx_buff.en) {
    if (int_type == I2C_IRQ_TYPE_STARTED) {
      send_addr(I2C_PORT, 0x68, 0);
    } else if (int_type == I2C_IRQ_TYPE_ADDR_SENT) {
      init_xmission(I2C_PORT, 0);
    } else if (int_type == I2C_IRQ_TYPE_TXE && i2c_tx_buff.eles_left) {
      send_data(I2C_PORT, &i2c_tx_buff);
    } else if (int_type == I2C_IRQ_TYPE_TXE) {
      end_tx(I2C_PORT, &i2c_tx_buff, &i2c_rx_buff);
    }
  } else if (i2c_rx_buff.en) {
    // RX:
    if (int_type == I2C_IRQ_TYPE_STARTED) {
      send_addr(I2C_PORT, 0x68, 1);
    } else if (int_type == I2C_IRQ_TYPE_ADDR_SENT) {
      init_xmission(I2C_PORT, 1);
      single_byte_rx_handler(I2C_PORT, &i2c_rx_buff);
    } else if (int_type == I2C_IRQ_TYPE_RXNE && i2c_rx_buff.eles_left) {
      receive_data(I2C_PORT, &i2c_rx_buff);
    }
  }

  return;
}

void I2C1_ER_IRQHandler(void) {
  I2CIRQType_t int_type = i2c_irq_error_handling(I2C1);
  return;
}

MPU6050Data convert_gyro_data(uint8_t *buf) {
  MPU6050Data ret;

  ret.accel_x = (uint16_t)(buf[0] << 8) | buf[1];
  ret.accel_y = (uint16_t)(buf[2] << 8) | buf[3];
  ret.accel_z = (uint16_t)(buf[4] << 8) | buf[5];
  ret.gyro_rx = (uint16_t)(buf[8] << 8) | buf[9];
  ret.gyro_ry = (uint16_t)(buf[10] << 8) | buf[11];
  ret.gyro_rz = (uint16_t)(buf[12] << 8) | buf[13];

  int16_t temp = (int16_t)((buf[6] << 8) | buf[7]) - 128;
  ret.temperature = (float)temp / 340 + 36.53;

  return ret;
}

void i2c_interrupt_driver_setup() {
  GPIO_peri_clock_control(I2C_GPIO_PORT, GPIO_CLOCK_ENABLE);
  GPIOConfig_t default_gpio_cfg = {.mode = GPIO_MODE_ALTFN,
                                   .speed = GPIO_SPEED_LOW,
                                   .float_resistor = GPIO_PUPDR_NONE,
                                   .output_type = GPIO_OP_TYPE_OPENDRAIN,
                                   .alt_func_num = 4};

  GPIOHandle_t i2c_sda_handle = {.p_GPIO_addr = I2C_GPIO_PORT, .cfg = default_gpio_cfg};
  i2c_sda_handle.cfg.pin_number = I2C_GPIO_SDA_PIN;
  GPIO_init(&i2c_sda_handle);

  GPIOHandle_t i2c_scl_handle = {.p_GPIO_addr = I2C_GPIO_PORT, .cfg = default_gpio_cfg};
  i2c_scl_handle.cfg.pin_number = I2C_GPIO_SCL_PIN;
  GPIO_init(&i2c_scl_handle);

  i2c_peri_clock_control(I2C_PORT, I2C_ENABLE);
  I2CHandle_t i2c_handle = {.addr = I2C_PORT,
                            .cfg = {.peri_clock_freq_hz = (uint32_t)16E6,
                                    .device_mode = I2C_DEVICE_MODE_MASTER,
                                    .scl_mode = I2C_SCL_MODE_SPEED_FM,
                                    .dma_enable = I2C_DISABLE,
                                    .enable_on_init = I2C_ENABLE}};
  i2c_init(&i2c_handle);

  // Add interrupt stuff here
  I2C_PORT->CR1 &= ~(1 << I2C_CR1_PE_Pos);

  I2C_PORT->CR2 |= (I2C_CR2_ITEVTEN | I2C_CR2_ITERREN);

  I2C_PORT->CR1 |= (1 << I2C_CR1_PE_Pos);
  NVIC_EnableIRQ(I2C1_EV_IRQn);
  NVIC_EnableIRQ(I2C1_ER_IRQn);
}
