/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <stdio.h>

#include "stm32f446xx.h"
#include "stm32f446xx_gpio.h"

#define FAST 100000
#define MEDIUM 300000
#define SLOW 1000000
#define WAIT(CNT)                              \
  do {                                         \
    for (int def_i = 0; def_i < CNT; def_i++); \
  } while (0)

/******* PINS *********/
#define LED_GREEN_PORT GPIOA
#define LED_GREEN_PIN 5

#define USER_PBUTTON_PORT GPIOC
#define USER_PBUTTON_PIN 13

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
#warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

void timer_setup(void);

/****** CUSTOM TIMER.h CODE STARTS HERE *******
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 **/

/**
  * Timer configuration struct
  * @timer_index: Timer 1, 2, 3, ..., 14
  * @channel: Timer channel
  * @timer_mode: Capture or compare mode, or PWM
  * @interrupt_en: Whether the interrupt is enabled or not
  * @base_clock_freq_hz: Base clock frequency of the timer (deterministic)
  * @timer_freq_hz: Desired frequency of the timer (user required)
  * @prescaler: Pre-scalar to run the timer through
*/

typedef struct {
  uint8_t channel;
  uint8_t timer_mode;
  uint8_t interrupt_en;
  uint8_t output_mode;
  uint32_t base_clock_freq_hz;
  uint32_t timer_freq_hz;
  uint16_t prescaler;
} TimerConfig_t;

typedef struct {
  TIM_TypeDef *p_base_addr;
  TimerConfig_t cfg;
} TimerHandle_t;

enum { TIMER_MODE_COMPARE = 0, TIMER_MODE_CAPTURE = 1, TIMER_MODE_PWM = 2 };
enum { TIMER_INTERRUPT_DISABLED = 0, TIMER_INTERRUPT_ENABLED = 1 };

void timer_peri_clock_control(const TIM_TypeDef *base_addr, const uint8_t en_state);

/****** END OF CUSTOM TIMER.h CODE STARTS HERE *******
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 **/

int main(void) {
  // RCC->CR |= RCC_CR_

  GPIO_peri_clock_control(LED_GREEN_PORT, GPIO_CLOCK_ENABLE);
  GPIO_peri_clock_control(USER_PBUTTON_PORT, GPIO_CLOCK_ENABLE);

  GPIO_Handle_t gpio_handle;
  GPIO_TypeDef **addr = &gpio_handle.p_GPIO_x;
  GPIO_PinConfig_t *cfg = &gpio_handle.GPIO_pin_config;

  *addr = LED_GREEN_PORT;
  cfg->GPIO_pin_number = LED_GREEN_PIN;
  cfg->GPIO_pin_mode = GPIO_MODE_OUT;
  cfg->GPIO_pin_speed = GPIO_SPEED_LOW;
  cfg->GPIO_pin_pupd_control = GPIO_PUPDR_NONE;
  cfg->GPIO_pin_out_type = GPIO_OP_TYPE_PUSHPULL;
  cfg->GPIO_pin_alt_func_mode = 0;
  GPIO_init(&gpio_handle);

  *addr = USER_PBUTTON_PORT;
  cfg->GPIO_pin_number = USER_PBUTTON_PIN;
  cfg->GPIO_pin_mode = GPIO_MODE_IT_FT;
  cfg->GPIO_pin_speed = GPIO_SPEED_LOW;
  cfg->GPIO_pin_pupd_control = GPIO_PUPDR_PULLDOWN;
  cfg->GPIO_pin_out_type = GPIO_OP_TYPE_PUSHPULL;
  cfg->GPIO_pin_alt_func_mode = 0;
  GPIO_init(&gpio_handle);
  GPIO_irq_interrupt_config(EXTI15_10_IRQn, GPIO_INT_ENABLE);
  // GPIO_irq_priority_config(EXTI15_10_IRQn, USER_PBUTTON_PIN);

  timer_setup();

  /* Loop forever */
  for (;;) {
  }
}

void timer_setup(void) {
  NVIC->ISER[TIM2_IRQn / 32] |= (1 << (TIM2_IRQn % 32));

  // Timer 2 //

  //Enable counter
  // 1. Select the counter clock (internal, external, prescaler).
  RCC->APB1ENR |= (1 << RCC_APB1ENR_TIM2EN_Pos);

  // Set timer 2 as upcounter
  TIM2->CR1 |= (1 << TIM_CR1_DIR_Pos);

  // 2. Write the desired data in the TIMx_ARR and TIMx_CCRx registers.
  TIM2->ARR = 1600;                       // Test these by toggling commenting on and off
  TIM2->CCR1 = (0 << TIM_CCR1_CCR1_Pos);  // Test these by toggling commenting on and off
                                          //
  // Set the prescaler value
  TIM2->PSC = 10000;

  // 3. Set the CCxIE and/or CCxDE bits if an interrupt and/or a DMA request is to be generated.
  TIM2->DIER |= (1 << TIM_DIER_CC1IE_Pos);

  // 4. Select the output mode. For example, one must write OCxM=011, OCxPE=0, CCxP=0 and CCxE=1 to toggle OCx output pin when CNT matches CCRx, CCRx preload is not used, OCx is enabled and active high.
  TIM2->CCER |= (1 << TIM_CCER_CC1E_Pos);
  TIM2->CCER &= ~(1 << TIM_CCER_CC1P_Pos);
  TIM2->CCMR1 = (0b011 << TIM_CCMR1_OC1M_Pos);

  // 5. Enable the counter by setting the CEN bit in the TIMx_CR1 register.CR1_CEN;
  TIM2->CR1 |= (1 << TIM_CR1_CEN_Pos);

  // NOTE: The timer on the STM32 Nucleo F446 board is set to 16MHz
}

void TIM2_IRQHandler(void) {
  if (TIM2->SR & (1 << TIM_SR_CC1IF_Pos)) {
    TIM2->SR &= ~(1 << TIM_SR_CC1IF_Pos);

    // Put any logic here for the interrupt
    GPIO_toggle_output_pin(LED_GREEN_PORT, LED_GREEN_PIN);
  }
}

void EXTI15_10_IRQHandler(void) {
  if (GPIO_irq_handling(USER_PBUTTON_PIN)) {
    GPIO_toggle_output_pin(LED_GREEN_PORT, LED_GREEN_PIN);
  }
}

/****** CUSTOM TIMER.c CODE STARTS HERE *******
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 **/

#define TIMERS {TIM1, TIM2, TIM3, TIM4, TIM5, TIM6, TIM7, TIM8, TIM9, TIM10, TIM11, TIM12, TIM13, TIM14}
#define TIMER_SIZE(arr) ((int)sizeof(arr) / sizeof(TIM_TypeDef *))

void timer_peri_clock_control(const TIM_TypeDef *base_addr, const uint8_t en_state) {
  if (base_addr == NULL) return;

  // Grab the index of the current timer
  const TIM_TypeDef *timers_arr[] = TIMERS;
  int i = 0;
  for (; i < TIMER_SIZE(timers_arr); i++) {
    if (timers_arr[i] == base_addr) break;
  }

  // Do nothing if the index is out of range
  if (i >= TIMER_SIZE(timers_arr)) return;
}
