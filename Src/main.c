/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <stdio.h>

#include "stm32f446xx.h"
#include "stm32f446xx_gpio.h"
#include "stm32f446xx_tim.h"

#define FAST 100000
#define MEDIUM 300000
#define SLOW 1000000
#define WAIT(CNT)                              \
  do {                                         \
    for (int def_i = 0; def_i < CNT; def_i++); \
  } while (0)

/******* PINS *********/
#define LED_GREEN_PORT GPIOA
#define LED_GREEN_PIN 5
#define LED_GREEN_ALT_FN 1

#define USER_PBUTTON_PORT GPIOC
#define USER_PBUTTON_PIN 13

#define INPUT_CAPTURE_GPIO_PORT GPIOB
#define INPUT_CAPTURE_GPIO_PIN 6
#define INPUT_CAPTURE_GPIO_ALT 2

/******* TIMERS ********/
#define TIM_TIMER_ADDR TIM5
#define TIM_CHANNEL 1

#define PWM_TIMER_ADDR TIM2
#define PWM_CHANNEL 4

#define INPUT_CAPTURE_ADDR TIM4
#define INPUT_CAPTURE_CHAN 1
#define OUTPUT_CAPTURE_CHAN_LO 2
#define OUTPUT_CAPTURE_CHAN_HI 3

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
#warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

int main(void) {
  // RCC->CR |= RCC_CR_

  GPIO_peri_clock_control(LED_GREEN_PORT, GPIO_CLOCK_ENABLE);
  GPIO_peri_clock_control(USER_PBUTTON_PORT, GPIO_CLOCK_ENABLE);
  GPIO_peri_clock_control(INPUT_CAPTURE_GPIO_PORT, GPIO_CLOCK_ENABLE);

  GPIO_Handle_t gpio_handle_1 = {.p_GPIO_x = LED_GREEN_PORT,
                                 .GPIO_pin_config = {.GPIO_pin_mode = GPIO_MODE_OUT,
                                                     .GPIO_pin_number = LED_GREEN_PIN,
                                                     .GPIO_pin_speed = GPIO_SPEED_LOW,
                                                     .GPIO_pin_out_type = GPIO_OP_TYPE_PUSHPULL,
                                                     .GPIO_pin_pupd_control = GPIO_PUPDR_NONE,
                                                     .GPIO_pin_alt_func_mode = 0}};
  GPIO_init(&gpio_handle_1);

  GPIO_Handle_t gpio_handle;
  GPIO_TypeDef **gpio_addr = &gpio_handle.p_GPIO_x;
  GPIO_PinConfig_t *gpio_cfg = &gpio_handle.GPIO_pin_config;

  *gpio_addr = GPIOB;
  gpio_cfg->GPIO_pin_number = 2;
  gpio_cfg->GPIO_pin_mode = GPIO_MODE_ALTFN;
  gpio_cfg->GPIO_pin_speed = GPIO_SPEED_LOW;
  gpio_cfg->GPIO_pin_pupd_control = GPIO_PUPDR_NONE;
  gpio_cfg->GPIO_pin_out_type = GPIO_OP_TYPE_PUSHPULL;
  gpio_cfg->GPIO_pin_alt_func_mode = 1;
  GPIO_init(&gpio_handle);

  *gpio_addr = USER_PBUTTON_PORT;
  gpio_cfg->GPIO_pin_number = USER_PBUTTON_PIN;
  gpio_cfg->GPIO_pin_mode = GPIO_MODE_IT_FT;
  gpio_cfg->GPIO_pin_speed = GPIO_SPEED_LOW;
  gpio_cfg->GPIO_pin_pupd_control = GPIO_PUPDR_PULLDOWN;
  gpio_cfg->GPIO_pin_out_type = GPIO_OP_TYPE_PUSHPULL;
  gpio_cfg->GPIO_pin_alt_func_mode = 0;
  GPIO_init(&gpio_handle);
  GPIO_irq_interrupt_config(EXTI15_10_IRQn, GPIO_INT_ENABLE);

  *gpio_addr = INPUT_CAPTURE_GPIO_PORT;
  gpio_cfg->GPIO_pin_number = INPUT_CAPTURE_GPIO_PIN;
  gpio_cfg->GPIO_pin_mode = GPIO_MODE_ALTFN;
  // gpio_cfg->GPIO_pin_mode = GPIO_MODE_IN;
  gpio_cfg->GPIO_pin_speed = GPIO_SPEED_HIGH;
  gpio_cfg->GPIO_pin_pupd_control = GPIO_PUPDR_PULLDOWN;  // Will need a PD when using switch
  gpio_cfg->GPIO_pin_out_type = GPIO_OP_TYPE_PUSHPULL;
  gpio_cfg->GPIO_pin_alt_func_mode = INPUT_CAPTURE_GPIO_ALT;
  GPIO_init(&gpio_handle);

  TimerHandle_t tim4_handle = {
      .p_base_addr = TIM4,
      .cfg = {
          .arr = 0xffff,
          .prescaler = 507,
          .channel_count = 3,
          .channel_1 = {.gpio_en = TIMER_GPIO_ENABLE,
                        .channel_mode = TIMER_CHANNEL_MODE_CAPTURE,
                        .interrupt_en = TIMER_INTERRUPT_ENABLE,
                        .capture_edge = TIMER_CAPTURE_BOTH_EDGE,
                        .capture_input_filter = TIMER_CAPTURE_FILTER_MEDIUM},
          .channel_2 = {.channel_mode = TIMER_CHANNEL_MODE_COMPARE, .interrupt_en = TIMER_INTERRUPT_ENABLE, .ccr = 0},
          .channel_3 = {
              .channel_mode = TIMER_CHANNEL_MODE_COMPARE, .interrupt_en = TIMER_INTERRUPT_ENABLE, .ccr = 0xffff / 4}}};
  timer_peri_clock_control(INPUT_CAPTURE_ADDR, TIMER_PERI_CLOCK_ENABLE);
  timer_init(&tim4_handle);
  NVIC_EnableIRQ(TIM4_IRQn);

  TimerHandle_t timer_handle;
  TIM_TypeDef **timer_addr = &timer_handle.p_base_addr;
  TimerConfig_t *timer_cfg = &timer_handle.cfg;

  // Timer 2 configuration
  timer_peri_clock_control(PWM_TIMER_ADDR, TIMER_PERI_CLOCK_ENABLE);
  *timer_addr = PWM_TIMER_ADDR;

  // overall timer specific
  timer_cfg->prescaler = 253;  // 16M / (PSC + 1) = ~65536
  timer_cfg->arr = 1000;
  timer_cfg->channel_count = 4;

  // channel specific
  timer_cfg->channel_4.interrupt_en = TIMER_INTERRUPT_DISABLE;
  timer_cfg->channel_4.ccr = 0;
  timer_cfg->channel_4.channel_mode = TIMER_CHANNEL_MODE_PWM_HI;
  timer_cfg->channel_4.gpio_en = TIMER_GPIO_ENABLE;

  timer_init(&timer_handle);

  /* Loop forever */
  for (;;) {
    // uint8_t val = GPIO_get_input(INPUT_CAPTURE_GPIO_PORT, INPUT_CAPTURE_GPIO_PIN);
    // GPIO_set_output(LED_GREEN_PORT, LED_GREEN_PIN, val);
    WAIT(FAST);
  }
}

void TIM4_IRQHandler(void) {
  if (timer_irq_handling(INPUT_CAPTURE_ADDR, INPUT_CAPTURE_CHAN)) {
    uint8_t rising_edge = GPIO_get_input(INPUT_CAPTURE_GPIO_PORT, INPUT_CAPTURE_GPIO_PIN);
    static uint16_t capture_val = 0;
    static uint16_t capture_val_falling = 0;

    // Rising edge
    if (rising_edge) {
      capture_val_falling = timer_get_current_ticks(INPUT_CAPTURE_ADDR, INPUT_CAPTURE_CHAN);
    }
    // Falling edge
    else {
      capture_val = timer_get_current_ticks(INPUT_CAPTURE_ADDR, INPUT_CAPTURE_CHAN) - capture_val_falling;
      float pwm_alpha = (float)capture_val / timer_get_period_ticks(INPUT_CAPTURE_ADDR);
      timer_set_pwm_percent(PWM_TIMER_ADDR, PWM_CHANNEL, pwm_alpha);
    }
  }

  if (timer_irq_handling(INPUT_CAPTURE_ADDR, OUTPUT_CAPTURE_CHAN_HI)) {
    GPIO_set_output(LED_GREEN_PORT, LED_GREEN_PIN, 1);
  }

  if (timer_irq_handling(INPUT_CAPTURE_ADDR, OUTPUT_CAPTURE_CHAN_LO)) {
    GPIO_set_output(LED_GREEN_PORT, LED_GREEN_PIN, 0);
  }
}

void EXTI15_10_IRQHandler(void) {
  if (GPIO_irq_handling(USER_PBUTTON_PIN)) {
    GPIO_toggle_output(LED_GREEN_PORT, LED_GREEN_PIN);
  }
}
